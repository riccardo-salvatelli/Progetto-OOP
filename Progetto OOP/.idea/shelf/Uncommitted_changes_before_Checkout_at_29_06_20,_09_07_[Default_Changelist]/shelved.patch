Index: src/Decriptazione.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>public class Decriptazione {\n\tstatic private double h = 0.01;\n\tstatic private int n = 100000;\n\n\tdouble x[] = new double[n];\n\tdouble y[] = new double[10000];\n\tx[0]= 3;\n\ty[0]= -2;\n\tprivate double[] autoval1 = new double[n];\n\tprivate double[] autoval2 = new double[n];\n\n\tstatic private double rho = 0.6;\n\tstatic private double w = 5.9;\n\tstatic private double k = 19.5;\n\tprivate double[] t = new double[(int) (n * h)];\n\n\tfor(int i=1; i<(int)(n*h); i++)\n\t{\n\t\tt[i] = t[i - 1] + h;\n\t}\n\n\tstatic private double k1x;\n\tstatic private double k2x;\n\tstatic private double k3x;\n\tstatic private double k4x;\n\tstatic private double k1y;\n\tstatic private double k2y;\n\tstatic private double k3y;\n\tstatic private double k4y;\n\n\tpublic double calcoloSequenza() {\n\t\t\n\t\tthis.trovaCaos(dimensione);\n\n\t\tfor (i = 0; i<dimensione; i++){\n\t\t\t\n\t\t\tk1x = Decriptazione.f1(this.t[i], this.x[i], this.y[i]);\n\t\t\tk1y = Decriptazione.f2(this.t[i], this.x[i], this.y[i]);\n\n\t\t\tk2x = Decriptazione.f1(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k1x, this.y[i] + 0.5 * h * k1y);\n\t\t\tk2y = Decriptazione.f2(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k1x, this.y[i] + 0.5 * h * k1y);\n\n\t\t\tk3x = Decriptazione.f1(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k2x, this.y[i] + 0.5 * h * k2y);\n\t\t\tk3y = Decriptazione.f2(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k2x, this.y[i] + 0.5 * h * k2y);\n\n\t\t\tk4x = Decriptazione.f1(this.t[i] + h, this.x[i] + k3x * h, this.y[i] + k3y * h);\n\t\t\tk4y = Decriptazione.f2(this.t[i] + h, this.x[i] + k3x * h, this.y[i] + k3y * h);\n\n\t\t\tthis.x[i + 1] = this.x[i] + (1 / 6) * (k1x + 2 * k2x + 2 * k3x + k4x) * h;\n\t\t\tthis.y[i + 1] = this.y[i] + (1 / 6) * (k1y + 2 * k2y + 2 * k3y + k4y) * h;\n\t\t}\n\t\tprivate double[][] stheta = new double[dimensione][2];\n\t\tfor(i=0; i<dimensione; i++){\n\t\t\t\n\t\t\tstheta[i][1] = Math.floor(Math.pow(this.x[i] - Math.floor(this.x[i]), 150));\n\t\t\tstheta[i][2] = Math.floor(Math.pow(this.y[i] - Math.floor(this.y[i]), 150));\n\t\t}\n\t\treturn stheta;\n\t}\n\n\tpublic void trovaCaos(int dim) {\n\t\tprivate boolean controllo1 = true;\n\t\tprivate boolean controllo2 = true;\n\t\tfor(i = 0; i<n; i++)\n\t\t{\n\t\t\tk1x = Decriptazione.f1(this.t[i], this.x[i], this.y[i]);\n\t\t\tk1y = Decriptazione.f2(this.t[i], this.x[i], this.y[i]);\n\n\t\t\tk2x = Decriptazione.f1(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k1x, this.y[i] + 0.5 * h * k1y);\n\t\t\tk2y = Decriptazione.f2(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k1x, this.y[i] + 0.5 * h * k1y);\n\n\t\t\tk3x = Decriptazione.f1(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k2x, this.y[i] + 0.5 * h * k2y);\n\t\t\tk3y = Decriptazione.f2(this.t[i] + 0.5 * h, this.x[i] + 0.5 * h * k2x, this.y[i] + 0.5 * h * k2y);\n\n\t\t\tk4x = Decriptazione.f1(this.t[i] + h, this.x[i] + k3x * h, this.y[i] + k3y * h);\n\t\t\tk4y = Decriptazione.f2(this.t[i] + h, this.x[i] + k3x * h, this.y[i] + k3y * h);\n\n\t\t\tthis.x[i + 1] = this.x[i] + (1 / 6) * (k1x + 2 * k2x + 2 * k3x + k4x) * h;\n\t\t\tthis.y[i + 1] = this.y[i] + (1 / 6) * (k1y + 2 * k2y + 2 * k3y + k4y) * h;\n\n\t\t\tthis.autoval1[i] = rho - 2 * (Math.pow(rho, 2))\n\t\t\t\t* (Math.pow(this.x[i], 2) + Math.sqrt(Math.pow(rho - 2 * rho * Math.pow(this.x[i], 2), 2)\n\t\t\t\t\t\t- (k * Math.sin(w * this.t[i]) - 4 * rho * this.x[i] * this.y[i])));\n\t\t\tthis.autoval2[i] = rho - 2 * (Math.pow(rho, 2))\n\t\t\t\t* (Math.pow(this.x[i], 2) - Math.sqrt(Math.pow(rho - 2 * rho * Math.pow(this.x[i], 2), 2)\n\t\t\t\t\t\t- (k * Math.sin(w * this.t[i]) - 4 * rho * this.x[i] * this.y[i])));\n\t\t\tif (controllo1 & this.autoval1[i] < 0) {\n\t\t\t\tcontrollo1 = false;\n\t\t\t}\n\t\t\tif (controllo2 & this.autoval2[i] > 0) {\n\t\t\t\tcontrollo2 = false;\n\t\t\t}\n\t\t\tif (!(controllo1 | controllo2)) {\n\t\t\t\tdouble appoggio = this.x[i];\n\t\t\t\tthis.x = new double[dim];\n\t\t\t\tthis.x[0] = appoggio;\n\t\t\t\tappoggio = this.y[i];\n\t\t\t\tthis.y = new double[dim];\n\t\t\t\tthis.y[0] = appoggio;\n\t\t\t\tthis.t = new double[dim * h];\n\t\t\t\tfor (int i = 1; i < (int) (n * h); i++) {\n\t\t\t\t\tthis.t[i] = this.t[i - 1] + h;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic public double f1(double t, double x, double y) {\n\t\treturn y;\n\t}\n\n\tstatic public double f2(double t, double x, double y) {\n\t\treturn -k*Math.sin(w*t)*x+2*rho*y-2*rho*(Math.pow(x, 2))*y;\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Decriptazione.java	(revision 13fdfde849dbdb9a2fe78fe5f750c5a9c65c38f0)
+++ src/Decriptazione.java	(date 1593379898777)
@@ -2,10 +2,10 @@
 	static private double h = 0.01;
 	static private int n = 100000;
 
-	double x[] = new double[n];
-	double y[] = new double[10000];
-	x[0]= 3;
-	y[0]= -2;
+	private double[] x = new double[n];
+	private double[] y = new double[10000];
+	x[0] = 3;
+	y[0] = -2;
 	private double[] autoval1 = new double[n];
 	private double[] autoval2 = new double[n];
 
@@ -28,8 +28,10 @@
 	static private double k3y;
 	static private double k4y;
 
-	public double calcoloSequenza() {
-		
+	public double[][] calcoloSequenza() {
+		double h = 0.01;
+		double[] x = new double[10];
+		x[0] = 2;
 		this.trovaCaos(dimensione);
 
 		for (i = 0; i<dimensione; i++){
